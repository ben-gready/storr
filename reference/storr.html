<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Object cache — storr • storr</title>

<!-- jquery -->
<script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script>
<!-- Bootstrap -->

<link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<!-- Font Awesome icons -->
<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">


<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script>
<script src="../pkgdown.js"></script>
  
  
<!-- mathjax -->
<script src='https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->


  </head>

  <body>
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">storr</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/storr.html">Get Started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="../articles/external.html">external</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
      </ul>
      
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/richfitz/storr">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      
      </header>

      <div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Object cache</h1>
    </div>

    
    <p>Create an object cache; a "storr".  A storr is a simple key-value
store where the actual content is stored in a content-addressible
way (so that duplicate objects are only stored once) and with a
caching layer so that repeated lookups are fast even if the
underlying storage driver is slow.</p>
    

    <pre class="usage"><span class='fu'>storr</span>(<span class='no'>driver</span>, <span class='kw'>default_namespace</span> <span class='kw'>=</span> <span class='st'>"objects"</span>)</pre>
    
    <h2 class="hasAnchor" id="arguments"><a class="anchor" href="#arguments"></a> Arguments</h2>
    <table class="ref-arguments">
    <colgroup><col class="name" /><col class="desc" /></colgroup>
    <tr>
      <th>driver</th>
      <td><p>A driver object</p></td>
    </tr>
    <tr>
      <th>default_namespace</th>
      <td><p>Default namespace to store objects in.
By default <code>"objects"</code> is used, but this might be useful to
have two diffent <code>storr</code> objects pointing at the same
underlying storage, but storing things in different namespaces.</p></td>
    </tr>
    </table>
    
    <h2 class="hasAnchor" id="details"><a class="anchor" href="#details"></a>Details</h2>

    <p>To create a storr you need to provide a "driver" object.  There
are three in this package: <code><a href='storr_environment.html'>driver_environment</a></code> for
ephemeral in-memory storage, <code><a href='storr_rds.html'>driver_rds</a></code> for
serialized storage to disk, and <code><a href='storr_dbi.html'>driver_dbi</a></code> for use
with DBI-compliant database interfaces.  The <code>redux</code> package
(on CRAN) provides a storr driver that uses Redis.</p>
<p>There are convenience functions (e.g.,
<code><a href='storr_environment.html'>storr_environment</a></code> and <code><a href='storr_rds.html'>storr_rds</a></code>) that
may be more convenient to use than this function.</p>
<p>Once a storr has been made it provides a number of methods.
Because storr uses <code>R6</code> (<code>R6Class</code>) objects, each
method is accessed by using <code>$</code> on a storr object (see the
examples).  The methods are described below in the "Methods"
section.</p>
<p>The <code>default_namespace</code> affects all methods of the storr
object that refer to namespaces; if a namespace is not given, then
the action (get, set, del, list, import, export) will affect the
<code>default_namespace</code>.  By default this is <code>"objects"</code>.</p>
    
    <h2 class="hasAnchor" id="methods"><a class="anchor" href="#methods"></a>Methods</h2>

    
    <dl class='dl-horizontal'>
<dt><code>destroy</code></dt><dd><p>Totally destroys the storr by telling the driver to destroy all the data and then deleting the driver.  This will remove all data and cannot be undone.
    <em>Usage:</em>
  <code>destroy()</code></p></dd>
<dt><code>flush_cache</code></dt><dd><p>Flush the temporary cache of objects that accumulates as the storr is used.  Should not need to be called often.
    <em>Usage:</em>
  <code>flush_cache()</code></p></dd>
<dt><code>set</code></dt><dd><p>Set a key to a value.
    <em>Usage:</em>
  <code>set(key, value, namespace = self$default_namespace, use_cache = TRUE)</code>
    <em>Arguments:</em>
  <ul>
<li><p><code>key</code>:   The key name.  Can be any string.</p></li>
<li><p><code>value</code>:   Any R object to store.  The object will generally be serialized (this is not actually true for the environment storr) so only objects that would usually be expected to survive a <code>saveRDS</code>/<code>readRDS</code> roundtrip will work.  This excludes Rcpp modules objects, external pointers, etc.  But any "normal" R object will work fine.</p></li>
<li><p><code>namespace</code>:   An optional namespace.  By default the default namespace that the storr was created with will be used (by default that is "objects").  Different namespaces allow different types of objects to be stored without risk of names colliding.  Use of namespaces is optional, but if used they must be a string.</p></li>
<li><p><code>use_cache</code>:   Use the internal cache to avoid reading or writing to the underlying storage if the data has already been seen (i.e., we have seen the hash of the object before).</p></li>
</ul>
    <em>Value</em>:
  Invisibly, the hash of the saved object.</p></dd>
<dt><code>set_by_value</code></dt><dd><p>Like <code>set</code> but saves the object with a key that is the same as the hash of the object.  Equivalent to <code>$set(digest::digest(value), value)</code>.
    <em>Usage:</em>
  <code>set_by_value(value, namespace = self$default_namespace, use_cache = TRUE)</code>
    <em>Arguments:</em>
  <ul>
<li><p><code>value</code>:   An R object to save, with the same limitations as <code>set</code>.</p></li>
<li><p><code>namespace</code>:   Optional namespace to save the key into.</p></li>
<li><p><code>use_cache</code>:   Use the internal cache to avoid reading or writing to the underlying storage if the data has already been seen (i.e., we have seen the hash of the object before).</p></li>
</ul></p></dd>
<dt><code>get</code></dt><dd><p>Retrieve an object from the storr.  If the requested value is not found then a <code>KeyError</code> will be raised (an R error, but can be caught with <code>tryCatch</code>; see the "storr" vignette).
    <em>Usage:</em>
  <code>get(key, namespace = self$default_namespace, use_cache = TRUE)</code>
    <em>Arguments:</em>
  <ul>
<li><p><code>key</code>:   The name of the key to get.</p></li>
<li><p><code>namespace</code>:   Optional namespace to look for the key within.</p></li>
<li><p><code>use_cache</code>:   Use the internal cache to avoid reading or writing to the underlying storage if the data has already been seen (i.e., we have seen the hash of the object before).</p></li>
</ul></p></dd>
<dt><code>get_hash</code></dt><dd><p>Retrieve the hash of an object stored in the storr (rather than the object itself).
    <em>Usage:</em>
  <code>get_hash(key, namespace = self$default_namespace)</code>
    <em>Arguments:</em>
  <ul>
<li><p><code>key</code>:   The name of the key to get.</p></li>
<li><p><code>namespace</code>:   Optional namespace to look for the key within.</p></li>
</ul></p></dd>
<dt><code>del</code></dt><dd><p>Delete an object fom the storr.
    <em>Usage:</em>
  <code>del(key, namespace = self$default_namespace)</code>
    <em>Arguments:</em>
  <ul>
<li><p><code>key</code>:   A vector of names of keys</p></li>
<li><p><code>namespace</code>:   The namespace of the key.</p></li>
</ul>
    <em>Value</em>:
  A logical vector the same length as the recycled length of key/namespace, with each element being <code>TRUE</code> if an object was deleted, <code>FALSE</code> otherwise.</p></dd>
<dt><code>duplicate</code></dt><dd><p>Duplicate the value of a set of keys into a second set of keys. Because the value stored against a key is just the hash of its content, this operation is very efficient - it does not make a copy of the data, just the pointer to the data (for more details see the storr vignette which explains the storage model in more detail).  Multiple keys (and/or namespaces) can be provided, with keys and nmespaces recycled as needed.  However, the number of source and destination keys must be the same.  The order of operation is not defined, so if the sets of keys are overlapping it is undefined behaviour.
    <em>Usage:</em>
  <code>duplicate(key_src, key_dest, namespace = self$default_namespace,
      namespace_src = namespace, namespace_dest = namespace)</code>
    <em>Arguments:</em>
  <ul>
<li><p><code>key_src</code>:   The source key (or vector of keys)</p></li>
<li><p><code>key_dest</code>:   The destination key</p></li>
<li><p><code>namespace</code>:   The namespace to copy keys within (used only of <code>namespace_src</code> and <code>namespace_dest</code> are not provided</p></li>
<li><p><code>namespace_src</code>:   The source namespace - use this where keys are duplicated across namespaces.</p></li>
<li><p><code>namespace_dest</code>:   The destination namespace - use this where keys are duplicated across namespaces.</p></li>
</ul></p></dd>
<dt><code>fill</code></dt><dd><p>Set one or more keys (potentially across namespaces) to the same value, without duplication effort serialisation, or duplicating data.
    <em>Usage:</em>
  <code>fill(key, value, namespace = self$default_namespace, use_cache = TRUE)</code>
    <em>Arguments:</em>
  <ul>
<li><p><code>key</code>:   A vector of keys to get; zero to many valid keys</p></li>
<li><p><code>value</code>:   A single value to set all keys to</p></li>
<li><p><code>namespace</code>:   A vector of namespaces (either a single namespace or a vector)</p></li>
<li><p><code>use_cache</code>:   Use the internal cache to avoid reading or writing to the underlying storage if the data has already been seen (i.e., we have seen the hash of the object before).</p></li>
</ul></p></dd>
<dt><code>clear</code></dt><dd><p>Clear a storr.  This function might be slow as it will iterate over each key.  Future versions of storr might allow drivers to implement a bulk clear method that will allow faster clearing.
    <em>Usage:</em>
  <code>clear(namespace = self$default_namespace)</code>
    <em>Arguments:</em>
  <ul>
<li><p><code>namespace</code>:   A namespace, to clear a single namespace, or <code>NULL</code> to clear all namespaces.</p></li>
</ul></p></dd>
<dt><code>exists</code></dt><dd><p>Test if a key exists within a namespace
    <em>Usage:</em>
  <code>exists(key, namespace = self$default_namespace)</code>
    <em>Arguments:</em>
  <ul>
<li><p><code>key</code>:   A vector of names of keys</p></li>
<li><p><code>namespace</code>:   The namespace of the key.</p></li>
</ul>
    <em>Value</em>:
  A logical vector the same length as the recycled length of key/namespace, with each element being <code>TRUE</code> if the object exists and <code>FALSE</code> otherwise.</p></dd>
<dt><code>exists_object</code></dt><dd><p>Test if an object with a given hash exists within the storr
    <em>Usage:</em>
  <code>exists_object(hash)</code>
    <em>Arguments:</em>
  <ul>
<li><p><code>hash</code>:   Hash to test</p></li>
</ul></p></dd>
<dt><code>mset</code></dt><dd><p>Set multiple elements at once
    <em>Usage:</em>
  <code>mset(key, value, namespace = self$default_namespace, use_cache = TRUE)</code>
    <em>Arguments:</em>
  <ul>
<li><p><code>key</code>:   A vector of keys to set; zero to many valid keys</p></li>
<li><p><code>value</code>:   A vector of values</p></li>
<li><p><code>namespace</code>:   A vector of namespaces (either a single namespace or a vector)</p></li>
<li><p><code>use_cache</code>:   Use the internal cache to avoid reading or writing to the underlying storage if the data has already been seen (i.e., we have seen the hash of the object before).</p></li>
</ul>
    <em>Details:</em>
  The arguments <code>key</code> and <code>namespace</code> are recycled such that either can be given as a scalar if the other is a vector. Other recycling is not allowed.</p></dd>
<dt><code>mget</code></dt><dd><p>Get multiple elements at once
    <em>Usage:</em>
  <code>mget(key, namespace = self$default_namespace, use_cache = TRUE,
      missing = NULL)</code>
    <em>Arguments:</em>
  <ul>
<li><p><code>key</code>:   A vector of keys to get; zero to many valid keys</p></li>
<li><p><code>namespace</code>:   A vector of namespaces (either a single namespace or a vector)</p></li>
<li><p><code>use_cache</code>:   Use the internal cache to avoid reading or writing to the underlying storage if the data has already been seen (i.e., we have seen the hash of the object before).</p></li>
<li><p><code>missing</code>:   Value to use for missing elements; by default <code>NULL</code> will be used.  IF <code>NULL</code> is a value that you might have stored in the storr you might want to use a different value here to distinguish "missing" from "set to NULL".  In addition, the <code>missing</code> attribute will indicate which values were missing.</p></li>
</ul>
    <em>Details:</em>
  The arguments <code>key</code> and <code>namespace</code> are recycled such that either can be given as a scalar if the other is a vector. Other recycling is not allowed.
    <em>Value</em>:
  A list with a length of the recycled length of <code>key</code> and <code>namespace</code>.  If any elements are missing, then an attribute <code>missing</code> will indicate the elements that are missing (this will be an integer vector with the indices of values were not found in the storr).</p></dd>
<dt><code>mset_by_value</code></dt><dd><p>Set multiple elements at once, by value.  A cross between <code>mset</code> and <code>set_by_value</code>.
    <em>Usage:</em>
  <code>mset_by_value(value, namespace = self$default_namespace, use_cache = TRUE)</code>
    <em>Arguments:</em>
  <ul>
<li><p><code>value</code>:   A list or vector of values to set into the storr.</p></li>
<li><p><code>namespace</code>:   A vector of namespaces</p></li>
<li><p><code>use_cache</code>:   Use the internal cache to avoid reading or writing to the underlying storage if the data has already been seen (i.e., we have seen the hash of the object before).</p></li>
</ul></p></dd>
<dt><code>gc</code></dt><dd><p>Garbage collect the storr.  Because keys do not directly map to objects, but instead map to hashes which map to objects, it is possible that hash/object pairs can persist with nothing pointing at them.  Running <code>gc</code> will remove these objects from the storr.
    <em>Usage:</em>
  <code>gc()</code></p></dd>
<dt><code>get_value</code></dt><dd><p>Get the content of an object given its hash.
    <em>Usage:</em>
  <code>get_value(hash, use_cache = TRUE)</code>
    <em>Arguments:</em>
  <ul>
<li><p><code>hash</code>:   The hash of the object to retrieve.</p></li>
<li><p><code>use_cache</code>:   Use the internal cache to avoid reading or writing to the underlying storage if the data has already been seen (i.e., we have seen the hash of the object before).</p></li>
</ul>
    <em>Value</em>:
  The object if it is present, otherwise throw a <code>HashError</code>.</p></dd>
<dt><code>set_value</code></dt><dd><p>Add an object value, but don't add a key.  You will not need to use this very often, but it is used internally.
    <em>Usage:</em>
  <code>set_value(value, use_cache = TRUE)</code>
    <em>Arguments:</em>
  <ul>
<li><p><code>value</code>:   An R object to set.</p></li>
<li><p><code>use_cache</code>:   Use the internal cache to avoid reading or writing to the underlying storage if the data has already been seen (i.e., we have seen the hash of the object before).</p></li>
</ul>
    <em>Value</em>:
  Invisibly, the hash of the object.</p></dd>
<dt><code>mset_value</code></dt><dd><p>Add a vector of object values, but don't add keys.  You will not need to use this very often, but it is used internally.
    <em>Usage:</em>
  <code>mset_value(values, use_cache = TRUE)</code>
    <em>Arguments:</em>
  <ul>
<li><p><code>values</code>:   A list of R objects to set</p></li>
<li><p><code>use_cache</code>:   Use the internal cache to avoid reading or writing to the underlying storage if the data has already been seen (i.e., we have seen the hash of the object before).</p></li>
</ul></p></dd>
<dt><code>list</code></dt><dd><p>List all keys stored in a namespace.
    <em>Usage:</em>
  <code>list(namespace = self$default_namespace)</code>
    <em>Arguments:</em>
  <ul>
<li><p><code>namespace</code>:   The namespace to list keys within.</p></li>
</ul>
    <em>Value</em>:
  A sorted character vector (possibly zero-length).</p></dd>
<dt><code>list_hashes</code></dt><dd><p>List all hashes stored in the storr
    <em>Usage:</em>
  <code>list_hashes()</code>
    <em>Value</em>:
  A sorted character vector (possibly zero-length).</p></dd>
<dt><code>list_namespaces</code></dt><dd><p>List all namespaces known to the database
    <em>Usage:</em>
  <code>list_namespaces()</code>
    <em>Value</em>:
  A sorted character vector (possibly zero-length).</p></dd>
<dt><code>import</code></dt><dd><p>Import R objects from an environment.
    <em>Usage:</em>
  <code>import(src, list = NULL, namespace = self$default_namespace,
      skip_missing = FALSE)</code>
    <em>Arguments:</em>
  <ul>
<li><p><code>src</code>:   Object to import objects from; can be a list, environment or another storr.</p></li>
<li><p><code>list</code>:   Names of of objects to import (or <code>NULL</code> to import all objects in <code>envir</code>.  If given it must be a character vector.  If named, the names of the character vector will be the names of the objects as created in the storr.</p></li>
<li><p><code>namespace</code>:   Namespace to get objects from, and to put objects into.  If <code>NULL</code>, all namespaces from <code>src</code> will be imported. If named, then the same rule is followed as <code>list</code>; <code>namespace = c(a = b)</code> will import the contents of namespace <code>b</code> as namespace <code>a</code>.</p></li>
<li><p><code>skip_missing</code>:   Logical, indicating if missing keys (specified in <code>list</code>) should be skipped over, rather than being treated as an error (the default).</p></li>
</ul></p></dd>
<dt><code>export</code></dt><dd><p>Export objects from the storr into something else.
    <em>Usage:</em>
  <code>export(dest, list = NULL, namespace = self$default_namespace,
      skip_missing = FALSE)</code>
    <em>Arguments:</em>
  <ul>
<li><p><code>dest</code>:   A target destination to export objects to; can be a list, environment, or another storr.  Use <code>list()</code> to export to a brand new list, or use <code>as.list(object)</code> for a shorthand.</p></li>
<li><p><code>list</code>:   Names of objects to export, with the same rules as <code>list</code> in <code>$import</code>.</p></li>
<li><p><code>namespace</code>:   Namespace to get objects from, and to put objects into.  If <code>NULL</code>, then this will export namespaces from this (source) storr into the destination; if there is more than one namespace,this is only possible if <code>dest</code> is a storr (otherwise there will be an error).</p></li>
<li><p><code>skip_missing</code>:   Logical, indicating if missing keys (specified in <code>list</code>) should be skipped over, rather than being treated as an error (the default).</p></li>
</ul>
    <em>Value</em>:
  Invisibly, <code>dest</code>, which allows use of <code>e &lt;- st$export(new.env())</code> and <code>x &lt;- st$export(list())</code>.</p></dd>
<dt><code>archive_export</code></dt><dd><p>Export objects from the storr into a special "archive" storr, which is an <code><a href='storr_rds.html'>storr_rds</a></code> with name mangling turned on (which encodes keys with base64 so that they do not voilate filesystem naming conventions).
    <em>Usage:</em>
  <code>archive_export(path, names = NULL, namespace = NULL)</code>
    <em>Arguments:</em>
  <ul>
<li><p><code>path</code>:   Path to create the storr at; can exist already.</p></li>
<li><p><code>names</code>:   As for <code>$export</code></p></li>
<li><p><code>namespace</code>:   Namespace to get objects from.  If <code>NULL</code>, then exports all namespaces found in this (source) storr.</p></li>
</ul></p></dd>
<dt><code>archive_import</code></dt><dd><p>Inverse of <code>archive_export</code>; import objects from a storr that was created by <code>archive_export</code>.
    <em>Usage:</em>
  <code>archive_import(path, names = NULL, namespace = NULL)</code>
    <em>Arguments:</em>
  <ul>
<li><p><code>path</code>:   Path of the exported storr.</p></li>
<li><p><code>names</code>:   As for <code>$import</code></p></li>
<li><p><code>namespace</code>:   Namespace to import objects into.  If <code>NULL</code>, then imports al namespaces from the source storr.</p></li>
</ul></p></dd>
</dl>
    

    <h2 class="hasAnchor" id="examples"><a class="anchor" href="#examples"></a>Examples</h2>
    <pre class="examples"><div class='input'><span class='no'>st</span> <span class='kw'>&lt;-</span> <span class='fu'>storr</span>(<span class='fu'><a href='storr_environment.html'>driver_environment</a></span>())
<span class='co'>## Set "mykey" to hold the mtcars dataset:</span>
<span class='no'>st</span>$<span class='fu'>set</span>(<span class='st'>"mykey"</span>, <span class='no'>mtcars</span>)
<span class='co'>## and get the object:</span>
<span class='no'>st</span>$<span class='fu'>get</span>(<span class='st'>"mykey"</span>)</div><div class='output co'>#&gt;                      mpg cyl  disp  hp drat    wt  qsec vs am gear carb
#&gt; Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4
#&gt; Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4
#&gt; Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
#&gt; Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1
#&gt; Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2
#&gt; Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1
#&gt; Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4
#&gt; Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
#&gt; Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
#&gt; Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4
#&gt; Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4
#&gt; Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3
#&gt; Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3
#&gt; Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3
#&gt; Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4
#&gt; Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4
#&gt; Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4
#&gt; Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1
#&gt; Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2
#&gt; Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1
#&gt; Toyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1
#&gt; Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2
#&gt; AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2
#&gt; Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4
#&gt; Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2
#&gt; Fiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1
#&gt; Porsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2
#&gt; Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2
#&gt; Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4
#&gt; Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6
#&gt; Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8
#&gt; Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2</div><div class='input'><span class='co'>## List known keys:</span>
<span class='no'>st</span>$<span class='fu'>list</span>()</div><div class='output co'>#&gt; [1] "mykey"</div><div class='input'><span class='co'>## List hashes</span>
<span class='no'>st</span>$<span class='fu'>list_hashes</span>()</div><div class='output co'>#&gt; [1] "a63c70e73b58d0823ab3bcbd3b543d6f"</div><div class='input'><span class='co'>## List keys in another namespace:</span>
<span class='no'>st</span>$<span class='fu'>list</span>(<span class='st'>"namespace2"</span>)</div><div class='output co'>#&gt; character(0)</div><div class='input'><span class='co'>## We can store things in other namespaces:</span>
<span class='no'>st</span>$<span class='fu'>set</span>(<span class='st'>"x"</span>, <span class='no'>mtcars</span>, <span class='st'>"namespace2"</span>)
<span class='no'>st</span>$<span class='fu'>set</span>(<span class='st'>"y"</span>, <span class='no'>mtcars</span>, <span class='st'>"namespace2"</span>)
<span class='no'>st</span>$<span class='fu'>list</span>(<span class='st'>"namespace2"</span>)</div><div class='output co'>#&gt; [1] "x" "y"</div><div class='input'><span class='co'>## Duplicate data do not cause duplicate storage: despite having three</span>
<span class='co'>## keys we only have one bit of data:</span>
<span class='no'>st</span>$<span class='fu'>list_hashes</span>()</div><div class='output co'>#&gt; [1] "a63c70e73b58d0823ab3bcbd3b543d6f"</div><div class='input'><span class='no'>st</span>$<span class='fu'>del</span>(<span class='st'>"mykey"</span>)

<span class='co'>## Storr objects can be created that have a default namespace that is</span>
<span class='co'>## not "objects" by using the \code{default_namespace} argument (this</span>
<span class='co'>## one also points at the same memory as the first storr).</span>
<span class='no'>st2</span> <span class='kw'>&lt;-</span> <span class='fu'>storr</span>(<span class='fu'><a href='storr_environment.html'>driver_environment</a></span>(<span class='no'>st</span>$<span class='no'>driver</span>$<span class='no'>envir</span>),
             <span class='kw'>default_namespace</span> <span class='kw'>=</span> <span class='st'>"namespace2"</span>)
<span class='co'>## All functions now use "namespace2" as the default namespace:</span>
<span class='no'>st2</span>$<span class='fu'>list</span>()</div><div class='output co'>#&gt; [1] "x" "y"</div><div class='input'><span class='no'>st2</span>$<span class='fu'>del</span>(<span class='st'>"x"</span>)
<span class='no'>st2</span>$<span class='fu'>del</span>(<span class='st'>"y"</span>)</div></pre>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
    <h2>Contents</h2>
    <ul class="nav nav-pills nav-stacked">
      <li><a href="#arguments">Arguments</a></li>
      
      <li><a href="#details">Details</a></li>

      <li><a href="#methods">Methods</a></li>
      
      <li><a href="#examples">Examples</a></li>
    </ul>

  </div>
</div>

      <footer>
      <div class="copyright">
  <p>Developed by Rich FitzJohn.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
   </div>

  </body>
</html>
